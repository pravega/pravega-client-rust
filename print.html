<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pravega Native Client</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quickStart.html"><strong aria-hidden="true">2.</strong> QuickStart</a></li><li class="chapter-item expanded "><a href="Rust/index.html"><strong aria-hidden="true">3.</strong> Rust Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Rust/EventClient.html"><strong aria-hidden="true">3.1.</strong> Event Client</a></li><li class="chapter-item expanded "><a href="Rust/ByteClient.html"><strong aria-hidden="true">3.2.</strong> Byte Client</a></li><li class="chapter-item expanded "><a href="Rust/contribution.html"><strong aria-hidden="true">3.3.</strong> Developer Corner</a></li></ol></li><li class="chapter-item expanded "><a href="Python/index.html"><strong aria-hidden="true">4.</strong> Python Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Python/PythonBindings.html"><strong aria-hidden="true">4.1.</strong> Python Bindings</a></li><li class="chapter-item expanded "><a href="Python/contribution.html"><strong aria-hidden="true">4.2.</strong> Developer Corner</a></li></ol></li><li class="chapter-item expanded "><a href="Nodejs/index.html"><strong aria-hidden="true">5.</strong> Nodejs Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Nodejs/NodejsBindings.html"><strong aria-hidden="true">5.1.</strong> Nodejs Bindings</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Pravega Native Client</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#pravega-rust-client-and-pravega-language-bindings-user-guide" id="pravega-rust-client-and-pravega-language-bindings-user-guide">Pravega Rust Client and Pravega language bindings user guide.</a></h1>
<p>Welcome to the Pravega Rust client and Pravega language bindings user guide! This book is a companion to 
<a href="https://docs.rs/pravega-client/0.3.6/pravega_client/">Pravega Rust Client</a> and the supported language bindings over the Pravega Rust
Client. At the moment this repository supports <a href="https://github.com/pravega/pravega-client-rust/tree/master/python">Python binding</a> to Pravega.</p>
<p>This book contains examples and documentation to explain all of Pravega Rust client's use cases in detail and the Python
language binding.</p>
<p>Please choose from the chapters on the left to jump to individual topics, or continue below to start with Pravega Rust Clients's README.</p>
<ul>
<li>
<p>User Guide: <a href="https://pravega.github.io/pravega-client-rust/">stable</a> | <a href="./index.html">master</a></p>
</li>
<li>
<p>API Documentation: <a href="https://docs.rs/pravega_client/">stable</a> |  <a href="./doc/index.html">master</a></p>
</li>
<li>
<p>Python API Documentation: <a href="">stable</a> | <a href="./python/pravega_client.html">master</a></p>
</li>
<li>
<p>Nodejs Documentation: <a href="./Nodejs/NodejsBindings.html">Tutorial</a> | <a href="./nodejs/index.html">API</a></p>
</li>
</ul>
<p><img src="https://github.com/pravega/pravega-client-rust/workflows/CIbuild/badge.svg" alt="CIbuild" />
<a href="https://codecov.io/gh/pravega/pravega-client-rust"><img src="https://codecov.io/gh/pravega/pravega-client-rust/branch/master/graph/badge.svg?token=XEjqMkINCV" alt="codecov" /></a></p>
<h1><a class="header" href="#rust-client-for-pravega" id="rust-client-for-pravega">Rust client for Pravega</a></h1>
<p>This is a native Rust client for <a href="https://www.pravega.io/">Pravega</a>. </p>
<p>Note: Pravega 0.9.0+ is required.</p>
<h2><a class="header" href="#status" id="status">Status</a></h2>
<p>Up to date status can be seen on <a href="https://github.com/pravega/pravega-client-rust/wiki/Design-plan">the wiki</a>.</p>
<h2><a class="header" href="#goals" id="goals">Goals</a></h2>
<p>The goal is to allow for clients to be written in Rust, as well as provide a common implementation for clients in higher level languages including Python and nodejs. </p>
<p>See the wiki for the <a href="https://github.com/pravega/pravega-client-rust/wiki/Supported-APIs">status of each language</a>.</p>
<h2><a class="header" href="#approach" id="approach">Approach</a></h2>
<p>The approach is to write a common native implementation of the internals of the client in Rust. Then use a C ABI to provide an interface for other languages to link against.</p>
<p>Finally for each supported language the low level API is translated into a high level API that is idiomatic for the language.</p>
<h2><a class="header" href="#book" id="book">Book</a></h2>
<p>Check out the Pravega Rust client <a href="https://pravega.github.io/pravega-client-rust/">book</a> for more details.</p>
<h2><a class="header" href="#license" id="license">License</a></h2>
<p>Pravega Rust client, all the source code, is released under the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License v2.0</a>.</p>
<h1><a class="header" href="#quick-start" id="quick-start">Quick Start</a></h1>
<p>This chapter demonstrates how to use Pravega Rust client to communicate to a standalone Pravega server.</p>
<h2><a class="header" href="#running-a-standalone-pravega-server" id="running-a-standalone-pravega-server">Running a standalone Pravega server</a></h2>
<p>Navigate to the <a href="https://github.com/pravega/pravega/releases">Pravega Release</a> page and download
a Pravega release. Note that <code>ByteStreamClient</code> requires Pravega 0.9.0+.</p>
<p>For example in a Linux environment, after downloading and decompressing <code>pravega-0.9.0.tgz</code>, we can start 
a minimal Pravega server by calling</p>
<pre><code>./pravega-0.9.0/bin/pravega-standalone
</code></pre>
<p>It spins up a Pravega standalone server that listens to <code>localhost:9090</code> by default.</p>
<h2><a class="header" href="#build-a-simple-application" id="build-a-simple-application">Build a simple application</a></h2>
<h3><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h3>
<p>Make sure you have Rust installed first, check out the <a href="https://www.rust-lang.org/tools/install">official website</a> of how to
install Rust.</p>
<h3><a class="header" href="#creating-a-new-project" id="creating-a-new-project">Creating a new project</a></h3>
<p>Create a new Rust project called <code>my_app</code></p>
<pre><code>cargo new my_app --bin
</code></pre>
<p>in the <code>Cargo.toml</code> file, add the following as dependencies</p>
<pre><code>[dependencies]
pravega-client = &quot;0.1&quot;
pravega-client-config = &quot;0.1&quot;
pravega-client-shared = &quot;0.1&quot;
tokio = &quot;1&quot;
</code></pre>
<h3><a class="header" href="#a-simple-app-that-writes-and-reads-events" id="a-simple-app-that-writes-and-reads-events">A simple app that writes and reads events</a></h3>
<p>Check out the <a href="https://github.com/pravega/pravega-client-rust/tree/master/examples">event write and read example</a>.</p>
<h1><a class="header" href="#rust-client" id="rust-client">Rust Client</a></h1>
<p>This section describes the Rust client APIs to interact with Pravega. </p>
<ul>
<li>Event API</li>
<li>Byte API</li>
</ul>
<h1><a class="header" href="#event-client" id="event-client">Event Client</a></h1>
<h2><a class="header" href="#event-writer" id="event-writer">Event Writer</a></h2>
<p>An EventWriter can be used to write events into the Pravega Stream.</p>
<p>An Event is a discrete item that can be read and processed independently.
Events are written atomically and will appear in the Stream exactly once. 
An optional routing key can be specified by the user. 
Events with the same routing key are guaranteed to be read back in the order they were written, 
while events with different routing keys may be read and processed in parallel.</p>
<p><a href="Rust/../doc/pravega_client/event/writer/struct.EventWriter.html">API docs</a>.</p>
<h2><a class="header" href="#event-reader" id="event-reader">Event Reader</a></h2>
<p>An EventReader can be used to read events from the Pravega Stream.</p>
<p>Every EventReader belongs to a ReaderGroup.
All the EventReaders within a ReaderGroup work together to from a Stream. This allows 
maximum read performance without duplicate reads. EventReaders internally coordinate with each other
within a ReaderGroup using a so-called Synchronizer.</p>
<p>For the details how Synchronizer works please check related blog <a href="https://blog.pravega.io/2019/02/15/exploring-state-synchronizer/">state synchronizer</a>.</p>
<p><a href="Rust/../doc/pravega_client/event/reader/struct.EventReader.html">API docs</a></p>
<h2><a class="header" href="#transactional-event-writer" id="transactional-event-writer">Transactional Event Writer</a></h2>
<p>Pravega transaction provides a mechanism for writing many events atomically.
A Transaction is unbounded in size but is bounded in time. If it has not been committed within a time window
specified at the time of its creation, it will be automatically aborted.</p>
<p>For more details please refer <a href="Rust/../doc/pravega_client/event/transactional_writer/struct.TransactionalEventWriter.html">API docs</a>.</p>
<h1><a class="header" href="#byte-client" id="byte-client">Byte Client</a></h1>
<p>Unlike EventWriter, ByteWriter writes raw bytes into Pravega Stream
without adding any headers or encoding. This means that the data stored in the Stream is a continuous
stream of bytes. Because of that, data written by ByteWriter can only be read by
ByteReader. </p>
<p>The Byte Client is useful in cases where a raw stream of bytes is desirable such as video streaming.</p>
<h2><a class="header" href="#example-walkthrough" id="example-walkthrough">Example walkthrough</a></h2>
<h3><a class="header" href="#create-a-clientfactory" id="create-a-clientfactory">Create a ClientFactory</a></h3>
<p>Applications should use <code>ClientFactory</code> to initialize components. The client doesn't expose
the underlying <code>new</code> method to users.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// assuming pravega controller is listening at localhost:9090
let config = ClientConfigBuilder::default()
    .controller_uri(&quot;localhost:9090&quot;)
    .build()
    .expect(&quot;creating config&quot;);

let client_factory = ClientFactory::new(config);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#create-a-byte-writer" id="create-a-byte-writer">Create a Byte Writer</a></h3>
<p>Assuming a new stream <code>mystream</code> has been created under scope <code>myscope</code> and
it contains a segment whose segmentId is 0.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let segment = ScopedSegment::from(&quot;myscope/mystream/0&quot;);
let mut byte_writer = client_factory.create_byte_writer(segment);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#seek-to-tail" id="seek-to-tail">Seek to tail</a></h3>
<p>Sometimes applications use Byte Writer to write to a segment that 
contains some preexisting data. In this case, we need to find out
the tail offset of the segment first.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>byte_writer.seek_to_tail();
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#write-some-data" id="write-some-data">Write some data</a></h3>
<p>It doesn't mean the data is persisted on the server side
when write method returns <code>Ok()</code>, user should call <code>writer.flush()</code> to ensure
all data has been acknowledged by the server.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let payload = &quot;hello world&quot;.to_string().into_bytes();
byte_writer.write(&amp;payload).expect(&quot;write&quot;);
byte_writer.flush().expect(&quot;flush&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#truncate-the-segment" id="truncate-the-segment">Truncate the segment</a></h3>
<p><code>ByteWriter</code> can also truncate the segment. Truncation means that the
data prior to some offset is not needed anymore. Truncated data cannot be read. 
Applications use truncation to save space on the server.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>byte_writer.truncate_data_before(4).await.expect(&quot;truncate segment&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#seal-the-segment" id="seal-the-segment">Seal the segment</a></h3>
<p>Sealing a segment is basically to make a segment read-only.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>byte_writer.seal().await.expect(&quot;seal segment&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#create-a-byte-reader" id="create-a-byte-reader">Create a Byte Reader</a></h3>
<p>Create a <code>ByteReader</code> to read the same segment we just write.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let segment = ScopedSegment::from(&quot;myscope/mystream/0&quot;);
let mut byte_reader = client_factory.create_byte_reader(segment);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#read-from-an-offset" id="read-from-an-offset">Read from an offset</a></h3>
<p><code>ByteReader</code> can seek to any offset in the segment and read from it. It also 
provides a useful method to show the current head of the readable offset. Remember that 
the truncated data is not readable anymore, so the current head of the readable offset
is the truncation offset.</p>
<p><code>read</code> method will block until some data are fetched from the server. If returned <code>size</code> is 0,
then it reaches the end of segment and no more data could be read from this offset.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let offset = byte_reader.current_head().await.expect(&quot;get current head offset&quot;);
let mut buf: Vec&lt;u8&gt; = vec![0; 4];
let size = byte_reader.read(&amp;mut buf).await.expect(&quot;read from byte stream&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#put-it-together" id="put-it-together">Put it together</a></h3>
<pre><pre class="playground"><code class="language-rust">use pravega_client_config::ClientConfigBuilder;
use pravega_client::client_factory::ClientFactory;
use pravega_client_shared::ScopedSegment;
use std::io::Write;

#[tokio::main]
async fn main() {
    let config = ClientConfigBuilder::default()
     .controller_uri(&quot;localhost:9090&quot;)
     .build()
     .expect(&quot;creating config&quot;);
    
    let client_factory = ClientFactory::new(config);
    
    let segment = ScopedSegment::from(&quot;myscope/mystream/0&quot;);
    
    // write
    let mut byte_writer = client_factory.create_byte_writer(segment);
    byte_writer.seek_to_tail().await;
    
    let payload = &quot;hello world&quot;.to_string().into_bytes();
    
    byte_writer.write(&amp;payload).await.expect(&quot;write&quot;);
    byte_writer.flush().await.expect(&quot;flush&quot;);

    byte_writer.truncate_data_before(4).await.expect(&quot;truncate segment&quot;);

    byte_writer.seal().await.expect(&quot;seal segment&quot;);

    // read
    let segment = ScopedSegment::from(&quot;myscope/mystream/0&quot;);
    let mut byte_reader = client_factory.create_byte_reader(segment).await;

    let offset = byte_reader.current_head().await.expect(&quot;get current head offset&quot;);
    let mut buf: Vec&lt;u8&gt; = vec![0; 4];
    let size = byte_reader.read(&amp;mut buf).await.expect(&quot;read from byte stream&quot;);
}
</code></pre></pre>
<p>For more details please refer <a href="Rust/../doc/pravega_client/byte">API docs</a>.</p>
<h1><a class="header" href="#developer-corner" id="developer-corner">Developer Corner</a></h1>
<h1><a class="header" href="#python-client" id="python-client">Python Client</a></h1>
<p>This section describes </p>
<ul>
<li>Python Client APIs to interact with Pravega.</li>
<li>Steps to generate Python Bindings for Pravega from the Rust client.</li>
</ul>
<h1><a class="header" href="#python-binding" id="python-binding">Python Binding</a></h1>
<p>The below section provides a Pravega Python API tutorial for the Rust based Pravega Native client. This tutorial is a 
companion to <a href="Python/../python/pravega_client.html">Pravega Python API</a></p>
<p>Also, check out the <a href="https://github.com/pravega/pravega-client-rust/tree/master/python">repo</a>.</p>
<h2><a class="header" href="#streammanager" id="streammanager">StreamManager</a></h2>
<p>A StreamManger is used to create a Scopes, Streams, Writers and Readers. It can also be used to perform
operations on the stream which include sealing a stream and deleting streams among others.</p>
<p>A StreamManager can be created by using a Controller URI. The below example snippet </p>
<pre><code class="language-python">import pravega_client
manager=pravega_client.StreamManager(&quot;tcp://127.0.0.1:9090&quot;)
# stream manager can be used to create scopes, streams, writers and readers against Pravega.
manager.create_scope(&quot;scope&quot;)
manager.create_stream(&quot;scope&quot;, &quot;stream&quot;, 1)
</code></pre>
<p>A StreamWriter can be used create a Stream writer. The below snippet is shows a sample pattern.</p>
<pre><code class="language-python">import pravega_client
manager=pravega_client.StreamManager(&quot;tcp://127.0.0.1:9090&quot;)
# create a writer against an already created Pravega scope and Stream.
writer=manager.create_writer(&quot;scope&quot;, &quot;stream&quot;)
</code></pre>
<p>A transactional Writer can be created using the StreamManager. The below example snippet shows a sample pattern.</p>
<pre><code class="language-python"> import pravega_client
 manager=pravega_client.StreamManager(&quot;tcp://127.0.0.1:9090&quot;)
# create a transactional writer against an already created Pravega scope and Stream.
 writer=manager.create_transaction_writer(&quot;scope&quot;, &quot;stream&quot;, &quot;123&quot;)
</code></pre>
<p>A ReaderGroup can be created using the StreamManager. Individual readers can be created using this ReaderGroup object.</p>
<pre><code class="language-python">import pravega_client
manager=pravega_client.StreamManager(&quot;tcp://127.0.0.1:9090&quot;)
# create a ReaderGroup rg1 against an already created Pravega scope and Stream.
event.reader_group=manager.create_reader_group(&quot;rg1&quot;, &quot;scope&quot;, &quot;stream&quot;)
</code></pre>
<h2><a class="header" href="#streamwriter" id="streamwriter">StreamWriter</a></h2>
<p>A StreamWriter object created using the StreamManager can be used to write events into the Pravega Stream. The events 
that are written will appear in the Stream exactly once. The event of type String is converted into bytes with <code>UTF-8</code> encoding.
The user can optionally specify the routing key. The StreamWriter can also write a byte array into the Pravega Stream 
with/without a routing key.</p>
<p>Note that the implementation provides retry logic to handle connection failures and service host failures. Internal 
retries will not violate the exactly-once semantic, so it is better to rely on them than to wrap this with custom retry logic.</p>
<pre><code class="language-python">import pravega_client
manager=pravega_client.StreamManager(&quot;tcp://127.0.0.1:9090&quot;)
# assuming the Pravega scope and stream are already created.
writer=manager.create_writer(&quot;scope&quot;, &quot;stream&quot;)
# write into Pravega stream without specifying the routing key.
writer.write_event(&quot;e1&quot;)
# write into Pravega stream by specifying the routing key.
writer.write_event(&quot;e2&quot;, &quot;key1&quot;) 
e=&quot;eventData&quot;                                                   
# convert the event object to a byte array.
e_bytes=e.encode(&quot;utf-8&quot;)                                       
# write into Pravega stream without specifying the routing key.    
writer.write_event_bytes(e_bytes)                                    
# write into Pravega stream by specifying the routing key.       
writer.write_event_bytes(e_bytes, &quot;key1&quot;)    
</code></pre>
<h2><a class="header" href="#transactionwriter" id="transactionwriter">TransactionWriter</a></h2>
<p>A TransactionWriter created using a StreamManager  writes Events to an Event stream transactionally. All events that are 
written as part of a transaction can be committed atomically by calling commit(). This will result in either all of those 
events going into the stream or none of them and the commit call failing with an exception.</p>
<p>Prior to committing a transaction, the events written to it cannot be read or otherwise seen by readers.</p>
<pre><code class="language-python">import pravega_client                                         
manager = pravega_client.StreamManager(&quot;tcp://127.0.0.1:9090&quot;)        
w1 = stream_manager.create_transaction_writer(scope,&quot;testTxn&quot;, 1)
# Begin a Transaction
txn1 = w1.begin_txn()
txn1.write_event(&quot;test event1&quot;)
txn1.write_event(&quot;test event2&quot;)
self.assertTrue(txn1.is_open(), &quot;Transaction is open&quot;)
# Commit a Transaction
txn1.commit()
                      
txn2 = w1.begin_txn()
txn2.write_event(&quot;test event1&quot;)
txn2.write_event(&quot;test event2&quot;)
self.assertTrue(txn2.is_open(), &quot;Transaction is open&quot;)
# Abort a transaction, none of the events will be written into the Stream.
txn2.abort()
</code></pre>
<h2><a class="header" href="#eventreader" id="eventreader">EventReader</a></h2>
<p>One or more EventReaders can be created from the ReaderGroup object created using the StreamManager. Every reader has 
an async method call <code>reader.get_segment_slice_async()</code> that returns a Python Future which completes when a segment slice 
is acquired for consumption.  It can contain one or more events and the user can iterate over the segment slice to read 
the events. If there are multiple segments in the stream then this API can return a segment slice of any segments in the
stream. The reader ensures that events returned by the stream are in order.</p>
<p>If multiple readers are created under the same reader group then the readers co-ordinate amongst themselves and divide 
the responsibility of reading from different segments in the Pravega stream.</p>
<p>A sample example snippet is shown below.</p>
<pre><code class="language-python">import pravega_client
manager = pravega_client.StreamManager(&quot;tcp://127.0.0.1:9090&quot;)
# assuming the Pravega scope and stream are already created.
reader_group = manager.create_reader_group(&quot;rg1&quot;, &quot;scope&quot;, &quot;stream&quot;)
reader = reader_group.create_reader(&quot;reader_id&quot;);
slice = await reader.get_segment_slice_async()
for event in slice:
    print(event.data())
</code></pre>
<h1><a class="header" href="#developercorner" id="developercorner">DeveloperCorner</a></h1>
<h1><a class="header" href="#python-bindings" id="python-bindings">Python Bindings</a></h1>
<h2><a class="header" href="#steps-to-generate-python-bindings-for-pravega" id="steps-to-generate-python-bindings-for-pravega">Steps to generate python bindings for Pravega:</a></h2>
<p><em>Pre-requisites</em></p>
<ul>
<li>Python 3.8 and up.</li>
</ul>
<ol>
<li>Ensure <code>cargo build</code> works fine.</li>
<li>There are two ways of running generating bindings. This describes the steps where maturin is manually installed.
<ul>
<li>Manually install <a href="https://github.com/PyO3/maturin">maturin</a> via <code>pip install maturin</code></li>
<li><code>maturin build --release --no-sdist --strip --manylinux off</code> This command auto detects the python interpreter and uses it. To
specify a specific interpreter using <code>--interpreter</code> option.</li>
<li><code>maturin sdist</code> to generate the source distribution. </li>
</ul>
</li>
<li>Steps to generate bindings using a docker approach.
<ul>
<li><code>docker run --rm -v --release --no-sdist --strip --manylinux off</code></li>
</ul>
</li>
<li>After the bindings are generated by either 2 or 3 the next step is to publish the artifacts.
<ul>
<li>The artifacts can be published via <a href="https://github.com/pypa/twine">twine</a>
<ul>
<li><code>pip install twine</code></li>
<li><code>twine upload -r testpypi target/*</code> this command uploads the artifacts to test.pypi</li>
<li><code>twine upload target/*</code> this command uploads the artifacts to pypi.</li>
</ul>
</li>
<li>The artifacts can be published via <a href="https://github.com/PyO3/maturin">maturin</a>
<ul>
<li><code>maturin publish -b pyo3 -p XXX -u YYY -r https://test.pypi.org/legacy/</code> this publishes the bindings to test.pypi</li>
<li><code>maturin publish -b pyo3 -p XXX -u YYY</code> This publishes the bindings to pypi.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1><a class="header" href="#nodejs-client" id="nodejs-client">Nodejs Client</a></h1>
<p>This section describes:</p>
<ul>
<li>Example of Nodejs client to interact with Pravega.</li>
<li>Steps to generate Nodejs Bindings for Pravega from the Rust client.</li>
<li><a href="Nodejs/./nodejs/index.html">Nodejs API reference</a>.</li>
</ul>
<h1><a class="header" href="#pravega-nodejs-client" id="pravega-nodejs-client">Pravega Nodejs Client</a></h1>
<p>This project provides a way to interact with <a href="https://cncf.pravega.io">Pravega</a> via a Nodejs client.</p>
<p>Pravega is an open source distributed storage service implementing Streams. It offers Stream as the main primitive for the foundation of reliable storage systems: a high-performance, durable, elastic, and unlimited append-only byte stream with strict ordering and consistency.</p>
<h2><a class="header" href="#install" id="install">Install</a></h2>
<p>The client library can be installed using npm or yarn.</p>
<pre><code class="language-shell">npm install @pravega/pravega
#or
yarn add @pravega/pravega
</code></pre>
<p>After the package is downloaded from the registry, a <code>node-pre-gyp install</code> will be triggered to pull the underlying Rust Node addon binary from the Github releases.</p>
<p>Note your os and architecture matters. Only <code>Windows</code>, <code>MacOS</code>, and <code>linux</code> with <code>x86_64</code> architecture come with a pre-built binary. If there is a connection problem or your platform is not supported, you need to build the native Node addon by pulling the repo and execute several commands to get the binary. They are stated below in the <em>Install Native Addons Manually</em> or <em>Development</em> section.</p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>After an <code>npm init</code>, add <code>&quot;type&quot;: &quot;module&quot;,</code> to your <code>package.json</code> so <code>node</code> can load ECMAScript modules correctly. We do provide a CommonJS distribution for legacy compatibility, so feel free to use <code>require()</code>.</p>
<pre><code class="language-javascript">import { StreamCut, StreamManager } from '@pravega/pravega';
// or the following if you are still using CommonJS
const { StreamCut, StreamManager } = require('@pravega/pravega');

const SCOPE = 'scope1';
const STREAM = 'stream1';
const DATA = 'Hello World!';

// Assume Pravega controller is listening at 127.0.0.1:9090
const stream_manager = StreamManager('tcp://127.0.0.1:9090', false, false, true);
// Assume the scope and stream don't exist.
stream_manager.create_scope(SCOPE);
// This will create a stream with only 1 segment.
stream_manager.create_stream(SCOPE, STREAM);

// Write event as string.
const stream_writer_1 = stream_manager.create_writer(SCOPE, STREAM);
await stream_writer_1.write_event(DATA);
await stream_writer_1.write_event(DATA, 'routing_key');
// Write event as bytes.
const enc = new TextEncoder();
const stream_writer_2 = stream_manager.create_writer(SCOPE, STREAM);
stream_writer_2.write_event_bytes(enc.encode(DATA));
stream_writer_2.write_event_bytes(enc.encode(DATA), 'routing_key');
// You can also write them in parallel and await flush.
await stream_writer_2.flush();

// Write events as a transaction.
const stream_txn_writer = stream_manager.create_transaction_writer(SCOPE, STREAM, BigInt(1));
const txn = await stream_txn_writer.begin_txn();
await txn.write_event(DATA);
await txn.write_event_bytes(enc.encode(DATA), 'routing_key');
// You may commit or abort the transaction.
// The previous events aren't preserved in Pravega until next operation.
await txn.commit();

// Create a reader group and a reader.
const reader_group_name = Math.random().toString(36).slice(2, 10);
const reader_name = Math.random().toString(36).slice(2, 10);
const stream_reader_group = stream_manager.create_reader_group(
    StreamCut.head(),
    reader_group_name,
    SCOPE,
    STREAM
);
const stream_reader = stream_reader_group.create_reader(reader_name);

// Read data back from stream.
// One `get_segment_slice()` call per segment.
const seg_slice = await stream_reader.get_segment_slice();
const dec = new TextDecoder('utf-8');
for (const event of seg_slice) {
    const raw_bytes = event.data();
    console.log(`Event at ${event.offset()} reads ${dec.decode(raw_bytes)}`);
}
// Release the current slice so other reader can lock and read this slice.
stream_reader.release_segment(seg_slice);
stream_reader.reader_offline();

// Clean up.
stream_manager.delete_reader_group(SCOPE, reader_group_name);
stream_manager.seal_stream(SCOPE, STREAM);
stream_manager.delete_stream(SCOPE, STREAM);
stream_manager.delete_scope(SCOPE);
</code></pre>
<p>With a <a href="https://cncf.pravega.io/docs/latest/deployment/run-local/"><code>pravega-standalone</code></a> running locally, you can see these outputs after running it:</p>
<pre><code class="language-shell">$ node --version
v16.15.0
$ node index.js
Event at 0 reads Hello World!
Event at 20 reads Hello World!
Event at 40 reads Hello World!
Event at 60 reads Hello World!
Event at 80 reads Hello World!
Event at 100 reads Hello World!
</code></pre>
<h2><a class="header" href="#supported-apis" id="supported-apis">Supported APIs</a></h2>
<p>Check the <a href="https://github.com/pravega/pravega-client-rust/wiki/Supported-APIs">Supported APIs Wiki page</a>.</p>
<p>A full API reference may be found <a href="https://pravega.github.io/pravega-client-rust/nodejs/index.html">here</a>.</p>
<h2><a class="header" href="#install-native-addons-manually" id="install-native-addons-manually">Install Native Addons Manually</a></h2>
<p>If you find any problems because of the unstable Github connection, you may first install the package without prebuilt binary through <code>npm install @pravega/pravega --ignore-scripts</code> and then manually download the <code>pravega-{tag}-node-v{node_api_version}-{os}-{arch}-{compiler}.tar.gz</code> tarball from the <a href="https://github.com/pravega/pravega-client-rust/releases">release page</a>. Extract the whole <code>dist</code> folder to <code>./node_modules/@pravega/pravega</code> and you should be good to go.</p>
<h2><a class="header" href="#development" id="development">Development</a></h2>
<p>To build or test this binding locally, Rust toolchain must be installed and <code>cargo build</code> can be executed without any problems in the parent project.</p>
<p>Then you need to install Nodejs related packages via <code>npm i</code> in this folder.</p>
<h3><a class="header" href="#tests" id="tests">Tests</a></h3>
<ol>
<li><code>npm run build-debug</code> to build a debug addon.</li>
<li><code>/path/to/pravega/bin/pravega-standalone</code></li>
<li><code>npm test</code></li>
</ol>
<h3><a class="header" href="#local-build-and-install" id="local-build-and-install">Local build and install</a></h3>
<ol>
<li><code>npm run release-native</code> to build a release addon.</li>
<li><code>npm run release-js</code> to build a release dist.</li>
<li><code>npm pack</code> to pack a local npm package.</li>
<li><code>npm i pravega-x.y.z.tgz</code> in your project and use it.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
