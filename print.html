<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pravega Native Client</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quickStart.html"><strong aria-hidden="true">2.</strong> QuickStart</a></li><li class="chapter-item expanded "><a href="Rust/index.html"><strong aria-hidden="true">3.</strong> Rust Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Rust/EventClient.html"><strong aria-hidden="true">3.1.</strong> Event Client</a></li><li class="chapter-item expanded "><a href="Rust/ByteClient.html"><strong aria-hidden="true">3.2.</strong> Byte Client</a></li><li class="chapter-item expanded "><a href="Rust/contribution.html"><strong aria-hidden="true">3.3.</strong> Developer Corner</a></li></ol></li><li class="chapter-item expanded "><a href="Nodejs/index.html"><strong aria-hidden="true">4.</strong> Nodejs Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Nodejs/NodejsBindings.html"><strong aria-hidden="true">4.1.</strong> Nodejs Bindings</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Pravega Native Client</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#pravega-rust-client-and-pravega-language-bindings-user-guide" id="pravega-rust-client-and-pravega-language-bindings-user-guide">Pravega Rust Client and Pravega language bindings user guide.</a></h1>
<p>Welcome to the Pravega Rust client and Pravega language bindings user guide! This book is a companion to 
<a href="https://docs.rs/pravega-client/0.3.6/pravega_client/">Pravega Rust Client</a> and the supported language bindings over the Pravega Rust
Client.</p>
<p>This book contains examples and documentation to explain all of Pravega Rust client's use cases in detail.</p>
<p>Please choose from the chapters on the left to jump to individual topics, or continue below to start with Pravega Rust Clients's README.</p>
<ul>
<li>
<p>User Guide: <a href="https://pravega.github.io/pravega-client-rust/">stable</a> | <a href="./index.html">master</a></p>
</li>
<li>
<p>API Documentation: <a href="https://docs.rs/pravega_client/">stable</a> |  <a href="./doc/index.html">master</a></p>
</li>
<li>
<p>Nodejs Documentation: <a href="./Nodejs/NodejsBindings.html">Tutorial</a> | <a href="./nodejs/index.html">API</a></p>
</li>
</ul>
<p><img src="https://github.com/pravega/pravega-client-rust/workflows/CIbuild/badge.svg" alt="CIbuild" />
<a href="https://codecov.io/gh/pravega/pravega-client-rust"><img src="https://codecov.io/gh/pravega/pravega-client-rust/branch/master/graph/badge.svg?token=XEjqMkINCV" alt="codecov" /></a></p>
<h1><a class="header" href="#rust-client-for-pravega" id="rust-client-for-pravega">Rust client for Pravega</a></h1>
<p>This is a native Rust client for <a href="https://www.pravega.io/">Pravega</a>. </p>
<p>Note: Pravega 0.9.0+ is required.</p>
<h2><a class="header" href="#status" id="status">Status</a></h2>
<p>Up to date status can be seen on <a href="https://github.com/pravega/pravega-client-rust/wiki/Design-plan">the wiki</a>.</p>
<h2><a class="header" href="#goals" id="goals">Goals</a></h2>
<p>The goal is to allow for clients to be written in Rust, as well as provide a common implementation for clients in higher level languages including nodejs. </p>
<p>See the wiki for the <a href="https://github.com/pravega/pravega-client-rust/wiki/Supported-APIs">status of each language</a>.</p>
<h2><a class="header" href="#approach" id="approach">Approach</a></h2>
<p>The approach is to write a common native implementation of the internals of the client in Rust. Then use a C ABI to provide an interface for other languages to link against.</p>
<p>Finally for each supported language the low level API is translated into a high level API that is idiomatic for the language.</p>
<h2><a class="header" href="#book" id="book">Book</a></h2>
<p>Check out the Pravega Rust client <a href="https://pravega.github.io/pravega-client-rust/">book</a> for more details.</p>
<h2><a class="header" href="#license" id="license">License</a></h2>
<p>Pravega Rust client, all the source code, is released under the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License v2.0</a>.</p>
<h1><a class="header" href="#quick-start" id="quick-start">Quick Start</a></h1>
<p>This chapter demonstrates how to use Pravega Rust client to communicate to a standalone Pravega server.</p>
<h2><a class="header" href="#running-a-standalone-pravega-server" id="running-a-standalone-pravega-server">Running a standalone Pravega server</a></h2>
<p>Navigate to the <a href="https://github.com/pravega/pravega/releases">Pravega Release</a> page and download
a Pravega release. Note that <code>ByteStreamClient</code> requires Pravega 0.9.0+.</p>
<p>For example in a Linux environment, after downloading and decompressing <code>pravega-0.9.0.tgz</code>, we can start 
a minimal Pravega server by calling</p>
<pre><code>./pravega-0.9.0/bin/pravega-standalone
</code></pre>
<p>It spins up a Pravega standalone server that listens to <code>localhost:9090</code> by default.</p>
<h2><a class="header" href="#build-a-simple-application" id="build-a-simple-application">Build a simple application</a></h2>
<h3><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h3>
<p>Make sure you have Rust installed first, check out the <a href="https://www.rust-lang.org/tools/install">official website</a> of how to
install Rust.</p>
<h3><a class="header" href="#creating-a-new-project" id="creating-a-new-project">Creating a new project</a></h3>
<p>Create a new Rust project called <code>my_app</code></p>
<pre><code>cargo new my_app --bin
</code></pre>
<p>in the <code>Cargo.toml</code> file, add the following as dependencies</p>
<pre><code>[dependencies]
pravega-client = &quot;0.1&quot;
pravega-client-config = &quot;0.1&quot;
pravega-client-shared = &quot;0.1&quot;
tokio = &quot;1&quot;
</code></pre>
<h3><a class="header" href="#a-simple-app-that-writes-and-reads-events" id="a-simple-app-that-writes-and-reads-events">A simple app that writes and reads events</a></h3>
<p>Check out the <a href="https://github.com/pravega/pravega-client-rust/tree/master/examples">event write and read example</a>.</p>
<h1><a class="header" href="#rust-client" id="rust-client">Rust Client</a></h1>
<p>This section describes the Rust client APIs to interact with Pravega. </p>
<ul>
<li>Event API</li>
<li>Byte API</li>
</ul>
<h1><a class="header" href="#event-client" id="event-client">Event Client</a></h1>
<h2><a class="header" href="#event-writer" id="event-writer">Event Writer</a></h2>
<p>An EventWriter can be used to write events into the Pravega Stream.</p>
<p>An Event is a discrete item that can be read and processed independently.
Events are written atomically and will appear in the Stream exactly once. 
An optional routing key can be specified by the user. 
Events with the same routing key are guaranteed to be read back in the order they were written, 
while events with different routing keys may be read and processed in parallel.</p>
<p><a href="Rust/../doc/pravega_client/event/writer/struct.EventWriter.html">API docs</a>.</p>
<h2><a class="header" href="#event-reader" id="event-reader">Event Reader</a></h2>
<p>An EventReader can be used to read events from the Pravega Stream.</p>
<p>Every EventReader belongs to a ReaderGroup.
All the EventReaders within a ReaderGroup work together to from a Stream. This allows 
maximum read performance without duplicate reads. EventReaders internally coordinate with each other
within a ReaderGroup using a so-called Synchronizer.</p>
<p>For the details how Synchronizer works please check related blog <a href="https://blog.pravega.io/2019/02/15/exploring-state-synchronizer/">state synchronizer</a>.</p>
<p><a href="Rust/../doc/pravega_client/event/reader/struct.EventReader.html">API docs</a></p>
<h2><a class="header" href="#transactional-event-writer" id="transactional-event-writer">Transactional Event Writer</a></h2>
<p>Pravega transaction provides a mechanism for writing many events atomically.
A Transaction is unbounded in size but is bounded in time. If it has not been committed within a time window
specified at the time of its creation, it will be automatically aborted.</p>
<p>For more details please refer <a href="Rust/../doc/pravega_client/event/transactional_writer/struct.TransactionalEventWriter.html">API docs</a>.</p>
<h1><a class="header" href="#byte-client" id="byte-client">Byte Client</a></h1>
<p>Unlike EventWriter, ByteWriter writes raw bytes into Pravega Stream
without adding any headers or encoding. This means that the data stored in the Stream is a continuous
stream of bytes. Because of that, data written by ByteWriter can only be read by
ByteReader. </p>
<p>The Byte Client is useful in cases where a raw stream of bytes is desirable such as video streaming.</p>
<h2><a class="header" href="#example-walkthrough" id="example-walkthrough">Example walkthrough</a></h2>
<h3><a class="header" href="#create-a-clientfactory" id="create-a-clientfactory">Create a ClientFactory</a></h3>
<p>Applications should use <code>ClientFactory</code> to initialize components. The client doesn't expose
the underlying <code>new</code> method to users.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// assuming pravega controller is listening at localhost:9090
let config = ClientConfigBuilder::default()
    .controller_uri(&quot;localhost:9090&quot;)
    .build()
    .expect(&quot;creating config&quot;);

let client_factory = ClientFactory::new(config);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#create-a-byte-writer" id="create-a-byte-writer">Create a Byte Writer</a></h3>
<p>Assuming a new stream <code>mystream</code> has been created under scope <code>myscope</code> and
it contains a segment whose segmentId is 0.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let segment = ScopedSegment::from(&quot;myscope/mystream/0&quot;);
let mut byte_writer = client_factory.create_byte_writer(segment);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#seek-to-tail" id="seek-to-tail">Seek to tail</a></h3>
<p>Sometimes applications use Byte Writer to write to a segment that 
contains some preexisting data. In this case, we need to find out
the tail offset of the segment first.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>byte_writer.seek_to_tail();
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#write-some-data" id="write-some-data">Write some data</a></h3>
<p>It doesn't mean the data is persisted on the server side
when write method returns <code>Ok()</code>, user should call <code>writer.flush()</code> to ensure
all data has been acknowledged by the server.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let payload = &quot;hello world&quot;.to_string().into_bytes();
byte_writer.write(&amp;payload).expect(&quot;write&quot;);
byte_writer.flush().expect(&quot;flush&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#truncate-the-segment" id="truncate-the-segment">Truncate the segment</a></h3>
<p><code>ByteWriter</code> can also truncate the segment. Truncation means that the
data prior to some offset is not needed anymore. Truncated data cannot be read. 
Applications use truncation to save space on the server.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>byte_writer.truncate_data_before(4).await.expect(&quot;truncate segment&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#seal-the-segment" id="seal-the-segment">Seal the segment</a></h3>
<p>Sealing a segment is basically to make a segment read-only.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>byte_writer.seal().await.expect(&quot;seal segment&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#create-a-byte-reader" id="create-a-byte-reader">Create a Byte Reader</a></h3>
<p>Create a <code>ByteReader</code> to read the same segment we just write.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let segment = ScopedSegment::from(&quot;myscope/mystream/0&quot;);
let mut byte_reader = client_factory.create_byte_reader(segment);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#read-from-an-offset" id="read-from-an-offset">Read from an offset</a></h3>
<p><code>ByteReader</code> can seek to any offset in the segment and read from it. It also 
provides a useful method to show the current head of the readable offset. Remember that 
the truncated data is not readable anymore, so the current head of the readable offset
is the truncation offset.</p>
<p><code>read</code> method will block until some data are fetched from the server. If returned <code>size</code> is 0,
then it reaches the end of segment and no more data could be read from this offset.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let offset = byte_reader.current_head().await.expect(&quot;get current head offset&quot;);
let mut buf: Vec&lt;u8&gt; = vec![0; 4];
let size = byte_reader.read(&amp;mut buf).await.expect(&quot;read from byte stream&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#put-it-together" id="put-it-together">Put it together</a></h3>
<pre><pre class="playground"><code class="language-rust">use pravega_client_config::ClientConfigBuilder;
use pravega_client::client_factory::ClientFactory;
use pravega_client_shared::ScopedSegment;
use std::io::Write;

#[tokio::main]
async fn main() {
    let config = ClientConfigBuilder::default()
     .controller_uri(&quot;localhost:9090&quot;)
     .build()
     .expect(&quot;creating config&quot;);
    
    let client_factory = ClientFactory::new(config);
    
    let segment = ScopedSegment::from(&quot;myscope/mystream/0&quot;);
    
    // write
    let mut byte_writer = client_factory.create_byte_writer(segment);
    byte_writer.seek_to_tail().await;
    
    let payload = &quot;hello world&quot;.to_string().into_bytes();
    
    byte_writer.write(&amp;payload).await.expect(&quot;write&quot;);
    byte_writer.flush().await.expect(&quot;flush&quot;);

    byte_writer.truncate_data_before(4).await.expect(&quot;truncate segment&quot;);

    byte_writer.seal().await.expect(&quot;seal segment&quot;);

    // read
    let segment = ScopedSegment::from(&quot;myscope/mystream/0&quot;);
    let mut byte_reader = client_factory.create_byte_reader(segment).await;

    let offset = byte_reader.current_head().await.expect(&quot;get current head offset&quot;);
    let mut buf: Vec&lt;u8&gt; = vec![0; 4];
    let size = byte_reader.read(&amp;mut buf).await.expect(&quot;read from byte stream&quot;);
}
</code></pre></pre>
<p>For more details please refer <a href="Rust/../doc/pravega_client/byte">API docs</a>.</p>
<h1><a class="header" href="#developer-corner" id="developer-corner">Developer Corner</a></h1>
<h1><a class="header" href="#nodejs-client" id="nodejs-client">Nodejs Client</a></h1>
<p>This section describes:</p>
<ul>
<li>Example of Nodejs client to interact with Pravega.</li>
<li>Steps to generate Nodejs Bindings for Pravega from the Rust client.</li>
<li><a href="Nodejs/./nodejs/index.html">Nodejs API reference</a>.</li>
</ul>
<h1><a class="header" href="#pravega-nodejs-client" id="pravega-nodejs-client">Pravega Nodejs Client</a></h1>
<p>This project provides a way to interact with <a href="https://cncf.pravega.io">Pravega</a> via a Nodejs client.</p>
<p>Pravega is an open source distributed storage service implementing Streams. It offers Stream as the main primitive for the foundation of reliable storage systems: a high-performance, durable, elastic, and unlimited append-only byte stream with strict ordering and consistency.</p>
<h2><a class="header" href="#install" id="install">Install</a></h2>
<p>The client library can be installed using npm or yarn.</p>
<pre><code class="language-shell">npm install @pravega/pravega
#or
yarn add @pravega/pravega
</code></pre>
<p>After the package is downloaded from the registry, a <code>node-pre-gyp install</code> will be triggered to pull the underlying Rust Node addon binary from the Github releases.</p>
<p>Note your os and architecture matters. Only <code>Windows</code>, <code>MacOS</code>, and <code>linux</code> with <code>x86_64</code> architecture come with a pre-built binary. If there is a connection problem or your platform is not supported, you need to build the native Node addon by pulling the repo and execute several commands to get the binary. They are stated below in the <em>Install Native Addons Manually</em> or <em>Development</em> section.</p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>After an <code>npm init</code>, add <code>&quot;type&quot;: &quot;module&quot;,</code> to your <code>package.json</code> so <code>node</code> can load ECMAScript modules correctly. We do provide a CommonJS distribution for legacy compatibility, so feel free to use <code>require()</code>.</p>
<pre><code class="language-javascript">import { StreamCut, StreamManager } from '@pravega/pravega';
// or the following if you are still using CommonJS
const { StreamCut, StreamManager } = require('@pravega/pravega');

const SCOPE = 'scope1';
const STREAM = 'stream1';
const DATA = 'Hello World!';

// Assume Pravega controller is listening at 127.0.0.1:9090
const stream_manager = StreamManager('tcp://127.0.0.1:9090', false, false, true);
// Assume the scope and stream don't exist.
stream_manager.create_scope(SCOPE);
// This will create a stream with only 1 segment.
stream_manager.create_stream(SCOPE, STREAM);

// Write event as string.
const stream_writer_1 = stream_manager.create_writer(SCOPE, STREAM);
await stream_writer_1.write_event(DATA);
await stream_writer_1.write_event(DATA, 'routing_key');
// Write event as bytes.
const enc = new TextEncoder();
const stream_writer_2 = stream_manager.create_writer(SCOPE, STREAM);
stream_writer_2.write_event_bytes(enc.encode(DATA));
stream_writer_2.write_event_bytes(enc.encode(DATA), 'routing_key');
// You can also write them in parallel and await flush.
await stream_writer_2.flush();

// Write events as a transaction.
const stream_txn_writer = stream_manager.create_transaction_writer(SCOPE, STREAM, BigInt(1));
const txn = await stream_txn_writer.begin_txn();
await txn.write_event(DATA);
await txn.write_event_bytes(enc.encode(DATA), 'routing_key');
// You may commit or abort the transaction.
// The previous events aren't preserved in Pravega until next operation.
await txn.commit();

// Create a reader group and a reader.
const reader_group_name = Math.random().toString(36).slice(2, 10);
const reader_name = Math.random().toString(36).slice(2, 10);
const stream_reader_group = stream_manager.create_reader_group(
    StreamCut.head(),
    reader_group_name,
    SCOPE,
    STREAM
);
const stream_reader = stream_reader_group.create_reader(reader_name);

// Read data back from stream.
// One `get_segment_slice()` call per segment.
const seg_slice = await stream_reader.get_segment_slice();
const dec = new TextDecoder('utf-8');
for (const event of seg_slice) {
    const raw_bytes = event.data();
    console.log(`Event at ${event.offset()} reads ${dec.decode(raw_bytes)}`);
}
// Release the current slice so other reader can lock and read this slice.
stream_reader.release_segment(seg_slice);
stream_reader.reader_offline();

// Clean up.
stream_manager.delete_reader_group(SCOPE, reader_group_name);
stream_manager.seal_stream(SCOPE, STREAM);
stream_manager.delete_stream(SCOPE, STREAM);
stream_manager.delete_scope(SCOPE);
</code></pre>
<p>With a <a href="https://cncf.pravega.io/docs/latest/deployment/run-local/"><code>pravega-standalone</code></a> running locally, you can see these outputs after running it:</p>
<pre><code class="language-shell">$ node --version
v16.15.0
$ node index.js
Event at 0 reads Hello World!
Event at 20 reads Hello World!
Event at 40 reads Hello World!
Event at 60 reads Hello World!
Event at 80 reads Hello World!
Event at 100 reads Hello World!
</code></pre>
<h2><a class="header" href="#supported-apis" id="supported-apis">Supported APIs</a></h2>
<p>Check the <a href="https://github.com/pravega/pravega-client-rust/wiki/Supported-APIs">Supported APIs Wiki page</a>.</p>
<p>A full API reference may be found <a href="https://pravega.github.io/pravega-client-rust/nodejs/index.html">here</a>.</p>
<h2><a class="header" href="#install-native-addons-manually" id="install-native-addons-manually">Install Native Addons Manually</a></h2>
<p>If you find any problems because of the unstable Github connection, you may first install the package without prebuilt binary through <code>npm install @pravega/pravega --ignore-scripts</code> and then manually download the <code>pravega-{tag}-node-v{node_api_version}-{os}-{arch}-{compiler}.tar.gz</code> tarball from the <a href="https://github.com/pravega/pravega-client-rust/releases">release page</a>. Extract the whole <code>dist</code> folder to <code>./node_modules/@pravega/pravega</code> and you should be good to go.</p>
<h2><a class="header" href="#development" id="development">Development</a></h2>
<p>To build or test this binding locally, Rust toolchain must be installed and <code>cargo build</code> can be executed without any problems in the parent project.</p>
<p>Then you need to install Nodejs related packages via <code>npm i</code> in this folder.</p>
<h3><a class="header" href="#tests" id="tests">Tests</a></h3>
<ol>
<li><code>npm run build-debug</code> to build a debug addon.</li>
<li><code>/path/to/pravega/bin/pravega-standalone</code></li>
<li><code>npm test</code></li>
</ol>
<h3><a class="header" href="#local-build-and-install" id="local-build-and-install">Local build and install</a></h3>
<ol>
<li><code>npm run release-native</code> to build a release addon.</li>
<li><code>npm run release-js</code> to build a release dist.</li>
<li><code>npm pack</code> to pack a local npm package.</li>
<li><code>npm i pravega-x.y.z.tgz</code> in your project and use it.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
