<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pravega Native Client</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quickStart.html"><strong aria-hidden="true">2.</strong> QuickStart</a></li><li class="chapter-item expanded "><a href="Rust/index.html"><strong aria-hidden="true">3.</strong> Rust Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Rust/EventClient.html"><strong aria-hidden="true">3.1.</strong> Event Client</a></li><li class="chapter-item expanded "><a href="Rust/ByteClient.html"><strong aria-hidden="true">3.2.</strong> Byte Client</a></li><li class="chapter-item expanded "><a href="Rust/contribution.html"><strong aria-hidden="true">3.3.</strong> Developer Corner</a></li></ol></li><li class="chapter-item expanded "><a href="Python/index.html"><strong aria-hidden="true">4.</strong> Python Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Python/PythonBindings.html"><strong aria-hidden="true">4.1.</strong> Python Bindings</a></li><li class="chapter-item expanded "><a href="Python/contribution.html"><strong aria-hidden="true">4.2.</strong> Developer Corner</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Pravega Native Client</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#pravega-rust-client-and-pravega-language-bindings-user-guide" id="pravega-rust-client-and-pravega-language-bindings-user-guide">Pravega Rust Client and Pravega language bindings user guide.</a></h1>
<p>Welcome to the Pravega Rust client and Pravega language bindings user guide! This book is a companion to 
<a href="https://docs.rs/pravega-client/0.2.0/pravega_client/">Pravega Rust Client</a> and the supported language bindings over the Pravega Rust
Client. At the moment this repository supports <a href="https://github.com/pravega/pravega-client-rust/tree/master/python_binding">Python binding</a> to Pravega.</p>
<p>This book contains examples and documentation to explain all of Pravega Rust client's use cases in detail and the Python
language binding.</p>
<p>Please choose from the chapters on the left to jump to individual topics, or continue below to start with Pravega Rust Clients's README.</p>
<ul>
<li>
<p>User Guide: <a href="https://pravega.github.io/pravega-client-rust/">stable</a> | <a href="./index.html">master</a></p>
</li>
<li>
<p>API Documentation: <a href="https://docs.rs/pravega_client/">stable</a> |  <a href="./doc/index.html">master</a></p>
</li>
<li>
<p>Python API Documentation: <a href="">stable</a> | <a href="./python/pravega_client.html">master</a></p>
</li>
</ul>
<p><img src="https://github.com/pravega/pravega-client-rust/workflows/CIbuild/badge.svg" alt="CIbuild" />
<a href="https://codecov.io/gh/pravega/pravega-client-rust"><img src="https://codecov.io/gh/pravega/pravega-client-rust/branch/master/graph/badge.svg?token=XEjqMkINCV" alt="codecov" /></a></p>
<h1><a class="header" href="#rust-client-for-pravega" id="rust-client-for-pravega">Rust client for Pravega</a></h1>
<p>This is a native Rust client for <a href="https://www.pravega.io/">Pravega</a>. </p>
<p>Note: Pravega 0.9.0+ is required.</p>
<h2><a class="header" href="#status" id="status">Status</a></h2>
<p>Up to date status can be seen on <a href="https://github.com/pravega/pravega-client-rust/wiki/Design-plan">the wiki</a>.</p>
<h2><a class="header" href="#goals" id="goals">Goals</a></h2>
<p>The goal is to allow for clients to be written in Rust, as well as provide a common implementation for clients in higher level languages including Python and nodejs. </p>
<p>See the wiki for the <a href="https://github.com/pravega/pravega-client-rust/wiki/Supported-APIs">status of each language</a>.</p>
<h2><a class="header" href="#approach" id="approach">Approach</a></h2>
<p>The approach is to write a common native implementation of the internals of the client in Rust. Then use a C ABI to provide an interface for other languages to link against.</p>
<p>Finally for each supported language the low level API is translated into a high level API that is idiomatic for the language.</p>
<h2><a class="header" href="#book" id="book">Book</a></h2>
<p>Check out the Pravega Rust client <a href="https://pravega.github.io/pravega-client-rust/">book</a> for more details.</p>
<h2><a class="header" href="#license" id="license">License</a></h2>
<p>Pravega Rust client, all the source code, is released under the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License v2.0</a>.</p>
<h1><a class="header" href="#quick-start" id="quick-start">Quick Start</a></h1>
<p>This chapter demonstrates how to use Pravega Rust client to communicate to a standalone Pravega server.</p>
<h2><a class="header" href="#running-a-standalone-pravega-server" id="running-a-standalone-pravega-server">Running a standalone Pravega server</a></h2>
<p>Navigate to the <a href="https://github.com/pravega/pravega/releases">Pravega Release</a> page and download
a Pravega release. Note that <code>ByteStreamClient</code> requires Pravega 0.9.0+.</p>
<p>For example in a Linux environment, after downloading and decompressing <code>pravega-0.9.0.tgz</code>, we can start 
a minimal Pravega server by calling</p>
<pre><code>./pravega-0.9.0/bin/pravega-standalone
</code></pre>
<p>It spins up a Pravega standalone server that listens to <code>localhost:9090</code> by default.</p>
<h2><a class="header" href="#build-a-simple-application" id="build-a-simple-application">Build a simple application</a></h2>
<h3><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h3>
<p>Make sure you have Rust installed first, check out the <a href="https://www.rust-lang.org/tools/install">official website</a> of how to
install Rust.</p>
<h3><a class="header" href="#creating-a-new-project" id="creating-a-new-project">Creating a new project</a></h3>
<p>Create a new Rust project called <code>my_app</code></p>
<pre><code>cargo new my_app --bin
</code></pre>
<p>in the <code>Cargo.toml</code> file, add the following as dependencies</p>
<pre><code>[dependencies]
pravega-client = &quot;0.1&quot;
pravega-client-config = &quot;0.1&quot;
pravega-client-shared = &quot;0.1&quot;
tokio = &quot;1&quot;
</code></pre>
<h3><a class="header" href="#a-simple-app-that-writes-and-reads-events" id="a-simple-app-that-writes-and-reads-events">A simple app that writes and reads events</a></h3>
<p>Check out the <a href="https://github.com/pravega/pravega-client-rust/tree/master/examples">event write and read example</a>.</p>
<h1><a class="header" href="#rust-client" id="rust-client">Rust Client</a></h1>
<p>This section describes the Rust client APIs to interact with Pravega. </p>
<ul>
<li>Event API</li>
<li>Byte API</li>
</ul>
<h1><a class="header" href="#event-client" id="event-client">Event Client</a></h1>
<h2><a class="header" href="#event-writer" id="event-writer">Event Writer</a></h2>
<p>An EventWriter can be used to write events into the Pravega Stream.</p>
<p>An Event is a discrete item that can be read and processed independently.
Events are written atomically and will appear in the Stream exactly once. 
An optional routing key can be specified by the user. 
Events with the same routing key are guaranteed to be read back in the order they were written, 
while events with different routing keys may be read and processed in parallel.</p>
<p><a href="Rust/../doc/pravega_client/event/writer/struct.EventWriter.html">API docs</a>.</p>
<h2><a class="header" href="#event-reader" id="event-reader">Event Reader</a></h2>
<p>An EventReader can be used to read events from the Pravega Stream.</p>
<p>Every EventReader belongs to a ReaderGroup.
All the EventReaders within a ReaderGroup work together to from a Stream. This allows 
maximum read performance without duplicate reads. EventReaders internally coordinate with each other
within a ReaderGroup using a so-called Synchronizer.</p>
<p>For the details how Synchronizer works please check related blog <a href="https://blog.pravega.io/2019/02/15/exploring-state-synchronizer/">state synchronizer</a>.</p>
<p><a href="Rust/../doc/pravega_client/event/reader/struct.EventReader.html">API docs</a></p>
<h2><a class="header" href="#transactional-event-writer" id="transactional-event-writer">Transactional Event Writer</a></h2>
<p>Pravega transaction provides a mechanism for writing many events atomically.
A Transaction is unbounded in size but is bounded in time. If it has not been committed within a time window
specified at the time of its creation, it will be automatically aborted.</p>
<p>For more details please refer <a href="Rust/../doc/pravega_client/event/transactional_writer/struct.TransactionalEventWriter.html">API docs</a>.</p>
<h1><a class="header" href="#byte-client" id="byte-client">Byte Client</a></h1>
<p>Unlike EventWriter, ByteWriter writes raw bytes into Pravega Stream
without adding any headers or encoding. This means that the data stored in the Stream is a continuous
stream of bytes. Because of that, data written by ByteWriter can only be read by
ByteReader. </p>
<p>The Byte Client is useful in cases where a raw stream of bytes is desirable such as video streaming.</p>
<h2><a class="header" href="#example-walkthrough" id="example-walkthrough">Example walkthrough</a></h2>
<h3><a class="header" href="#create-a-clientfactory" id="create-a-clientfactory">Create a ClientFactory</a></h3>
<p>Applications should use <code>ClientFactory</code> to initialize components. The client doesn't expose
the underlying <code>new</code> method to users.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// assuming pravega controller is listening at localhost:9090
let config = ClientConfigBuilder::default()
    .controller_uri(&quot;localhost:9090&quot;)
    .build()
    .expect(&quot;creating config&quot;);

let client_factory = ClientFactory::new(config);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#create-a-byte-writer" id="create-a-byte-writer">Create a Byte Writer</a></h3>
<p>Assuming a new stream <code>mystream</code> has been created under scope <code>myscope</code> and
it contains a segment whose segmentId is 0.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let segment = ScopedSegment::from(&quot;myscope/mystream/0&quot;);
let mut byte_writer = client_factory.create_byte_writer(segment);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#seek-to-tail" id="seek-to-tail">Seek to tail</a></h3>
<p>Sometimes applications use Byte Writer to write to a segment that 
contains some preexisting data. In this case, we need to find out
the tail offset of the segment first.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>byte_writer.seek_to_tail();
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#write-some-data" id="write-some-data">Write some data</a></h3>
<p>It doesn't mean the data is persisted on the server side
when write method returns <code>Ok()</code>, user should call <code>writer.flush()</code> to ensure
all data has been acknowledged by the server.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let payload = &quot;hello world&quot;.to_string().into_bytes();
byte_writer.write(&amp;payload).expect(&quot;write&quot;);
byte_writer.flush().expect(&quot;flush&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#truncate-the-segment" id="truncate-the-segment">Truncate the segment</a></h3>
<p><code>ByteWriter</code> can also truncate the segment. Truncation means that the
data prior to some offset is not needed anymore. Truncated data cannot be read. 
Applications use truncation to save space on the server.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>byte_writer.truncate_data_before(4).await.expect(&quot;truncate segment&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#seal-the-segment" id="seal-the-segment">Seal the segment</a></h3>
<p>Sealing a segment is basically to make a segment read-only.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>byte_writer.seal().await.expect(&quot;seal segment&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#create-a-byte-reader" id="create-a-byte-reader">Create a Byte Reader</a></h3>
<p>Create a <code>ByteReader</code> to read the same segment we just write.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let segment = ScopedSegment::from(&quot;myscope/mystream/0&quot;);
let mut byte_reader = client_factory.create_byte_reader(segment);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#read-from-an-offset" id="read-from-an-offset">Read from an offset</a></h3>
<p><code>ByteReader</code> can seek to any offset in the segment and read from it. It also 
provides a useful method to show the current head of the readable offset. Remember that 
the truncated data is not readable anymore, so the current head of the readable offset
is the truncation offset.</p>
<p><code>read</code> method will block until some data are fetched from the server. If returned <code>size</code> is 0,
then it reaches the end of segment and no more data could be read from this offset.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let offset = byte_reader.current_head().expect(&quot;get current head offset&quot;);
let mut buf: Vec&lt;u8&gt; = vec![0; 4];
let size = byte_reader.read(&amp;mut buf).expect(&quot;read from byte stream&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#put-it-together" id="put-it-together">Put it together</a></h3>
<pre><pre class="playground"><code class="language-rust">use pravega_client_config::ClientConfigBuilder;
use pravega_client::client_factory::ClientFactory;
use pravega_client_shared::ScopedSegment;
use std::io::Write;

fn main() {
    let config = ClientConfigBuilder::default()
     .controller_uri(&quot;localhost:9090&quot;)
     .build()
     .expect(&quot;creating config&quot;);
    
    let client_factory = ClientFactory::new(config);
    
    let segment = ScopedSegment::from(&quot;myscope/mystream/0&quot;);
    
    // write
    let mut byte_writer = client_factory.create_byte_writer(segment);
    byte_writer.seek_to_tail();
    
    let payload = &quot;hello world&quot;.to_string().into_bytes();
    
    byte_writer.write(&amp;payload).expect(&quot;write&quot;);
    byte_writer.flush().expect(&quot;flush&quot;);

    client_factory.runtime().block_on(byte_writer.truncate_data_before(4)).expect(&quot;truncate segment&quot;);

    client_factory.runtime().block_on(byte_writer.seal()).expect(&quot;seal segment&quot;);

    // read
    let segment = ScopedSegment::from(&quot;myscope/mystream/0&quot;);
    let mut byte_reader = client_factory.create_byte_reader(segment);

    let offset = byte_reader.current_head().expect(&quot;get current head offset&quot;);
    let mut buf: Vec&lt;u8&gt; = vec![0; 4];
    let size = byte_reader.read(&amp;mut buf).expect(&quot;read from byte stream&quot;);
}
</code></pre></pre>
<p>For more details please refer <a href="Rust/../doc/pravega_client/byte">API docs</a>.</p>
<h1><a class="header" href="#developer-corner" id="developer-corner">Developer Corner</a></h1>
<h1><a class="header" href="#python-client" id="python-client">Python Client</a></h1>
<p>This section describes </p>
<ul>
<li>Python Client APIs to interact with Pravega.</li>
<li>Steps to generate Python Bindings for Pravega from the Rust client.</li>
</ul>
<h1><a class="header" href="#python-binding" id="python-binding">Python Binding</a></h1>
<p>The below section provides a Pravega Python API tutorial for the Rust based Pravega Native client. This tutorial is a 
companion to <a href="Python/../python/pravega_client.html">Pravega Python API</a></p>
<p>Also, check out the <a href="https://github.com/pravega/pravega-client-rust/tree/master/python_binding">repo</a>.</p>
<h2><a class="header" href="#streammanager" id="streammanager">StreamManager</a></h2>
<p>A StreamManger is used to create a Scopes, Streams, Writers and Readers. It can also be used to perform
operations on the stream which include sealing a stream and deleting streams among others.</p>
<p>A StreamManager can be created by using a Controller URI. The below example snippet </p>
<pre><code class="language-python">import pravega_client
manager=pravega_client.StreamManager(&quot;tcp://127.0.0.1:9090&quot;)
# stream manager can be used to create scopes, streams, writers and readers against Pravega.
manager.create_scope(&quot;scope&quot;)
manager.create_stream(&quot;scope&quot;, &quot;stream&quot;, 1)
</code></pre>
<p>A StreamWriter can be used create a Stream writer. The below snippet is shows a sample pattern.</p>
<pre><code class="language-python">import pravega_client
manager=pravega_client.StreamManager(&quot;tcp://127.0.0.1:9090&quot;)
# create a writer against an already created Pravega scope and Stream.
writer=manager.create_writer(&quot;scope&quot;, &quot;stream&quot;)
</code></pre>
<p>A transactional Writer can be created using the StreamManager. The below example snippet shows a sample pattern.</p>
<pre><code class="language-python"> import pravega_client
 manager=pravega_client.StreamManager(&quot;tcp://127.0.0.1:9090&quot;)
# create a transactional writer against an already created Pravega scope and Stream.
 writer=manager.create_transaction_writer(&quot;scope&quot;, &quot;stream&quot;, &quot;123&quot;)
</code></pre>
<p>A ReaderGroup can be created using the StreamManager. Individual readers can be created using this ReaderGroup object.</p>
<pre><code class="language-python">import pravega_client
manager=pravega_client.StreamManager(&quot;tcp://127.0.0.1:9090&quot;)
# create a ReaderGroup rg1 against an already created Pravega scope and Stream.
event.reader_group=manager.create_reader_group(&quot;rg1&quot;, &quot;scope&quot;, &quot;stream&quot;)
</code></pre>
<h2><a class="header" href="#streamwriter" id="streamwriter">StreamWriter</a></h2>
<p>A StreamWriter object created using the StreamManager can be used to write events into the Pravega Stream. The events 
that are written will appear in the Stream exactly once. The event of type String is converted into bytes with <code>UTF-8</code> encoding.
The user can optionally specify the routing key. The StreamWriter can also write a byte array into the Pravega Stream 
with/without a routing key.</p>
<p>Note that the implementation provides retry logic to handle connection failures and service host failures. Internal 
retries will not violate the exactly-once semantic, so it is better to rely on them than to wrap this with custom retry logic.</p>
<pre><code class="language-python">import pravega_client
manager=pravega_client.StreamManager(&quot;tcp://127.0.0.1:9090&quot;)
# assuming the Pravega scope and stream are already created.
writer=manager.create_writer(&quot;scope&quot;, &quot;stream&quot;)
# write into Pravega stream without specifying the routing key.
writer.write_event(&quot;e1&quot;)
# write into Pravega stream by specifying the routing key.
writer.write_event(&quot;e2&quot;, &quot;key1&quot;) 
e=&quot;eventData&quot;                                                   
# convert the event object to a byte array.
e_bytes=e.encode(&quot;utf-8&quot;)                                       
# write into Pravega stream without specifying the routing key.    
writer.write_event_bytes(e_bytes)                                    
# write into Pravega stream by specifying the routing key.       
writer.write_event_bytes(e_bytes, &quot;key1&quot;)    
</code></pre>
<h2><a class="header" href="#transactionwriter" id="transactionwriter">TransactionWriter</a></h2>
<p>A TransactionWriter created using a StreamManager  writes Events to an Event stream transactionally. All events that are 
written as part of a transaction can be committed atomically by calling commit(). This will result in either all of those 
events going into the stream or none of them and the commit call failing with an exception.</p>
<p>Prior to committing a transaction, the events written to it cannot be read or otherwise seen by readers.</p>
<pre><code class="language-python">import pravega_client                                         
manager = pravega_client.StreamManager(&quot;tcp://127.0.0.1:9090&quot;)        
w1 = stream_manager.create_transaction_writer(scope,&quot;testTxn&quot;, 1)
# Begin a Transaction
txn1 = w1.begin_txn()
txn1.write_event(&quot;test event1&quot;)
txn1.write_event(&quot;test event2&quot;)
self.assertTrue(txn1.is_open(), &quot;Transaction is open&quot;)
# Commit a Transaction
txn1.commit()
                      
txn2 = w1.begin_txn()
txn2.write_event(&quot;test event1&quot;)
txn2.write_event(&quot;test event2&quot;)
self.assertTrue(txn2.is_open(), &quot;Transaction is open&quot;)
# Abort a transaction, none of the events will be written into the Stream.
txn2.abort()
</code></pre>
<h2><a class="header" href="#eventreader" id="eventreader">EventReader</a></h2>
<p>One or more EventReaders can be created from the ReaderGroup object created using the StreamManager. Every reader has 
an async method call <code>reader.get_segment_slice_async()</code> that returns a Python Future which completes when a segment slice 
is acquired for consumption.  It can contain one or more events and the user can iterate over the segment slice to read 
the events. If there are multiple segments in the stream then this API can return a segment slice of any segments in the
stream. The reader ensures that events returned by the stream are in order.</p>
<p>If multiple readers are created under the same reader group then the readers co-ordinate amongst themselves and divide 
the responsibility of reading from different segments in the Pravega stream.</p>
<p>A sample example snippet is shown below.</p>
<pre><code class="language-python">import pravega_client
manager = pravega_client.StreamManager(&quot;tcp://127.0.0.1:9090&quot;)
# assuming the Pravega scope and stream are already created.
reader_group = manager.create_reader_group(&quot;rg1&quot;, &quot;scope&quot;, &quot;stream&quot;)
reader = reader_group.create_reader(&quot;reader_id&quot;);
slice = await reader.get_segment_slice_async()
for event in slice:
    print(event.data())
</code></pre>
<h1><a class="header" href="#developercorner" id="developercorner">DeveloperCorner</a></h1>
<h1><a class="header" href="#python-bindings" id="python-bindings">Python Bindings</a></h1>
<h2><a class="header" href="#steps-to-generate-python-bindings-for-pravega" id="steps-to-generate-python-bindings-for-pravega">Steps to generate python bindings for Pravega:</a></h2>
<p><em>Pre-requisites</em></p>
<ul>
<li>Python 3.8 and up.</li>
</ul>
<ol>
<li>Ensure <code>cargo build</code> works fine.</li>
<li>There are two ways of running generating bindings. This describes the steps where maturin is manually installed.
<ul>
<li>Manually install <a href="https://github.com/PyO3/maturin">maturin</a> via <code>pip install maturin</code></li>
<li><code>maturin build --release --no-sdist --strip --manylinux off</code> This command auto detects the python interpreter and uses it. To
specify a specific interpreter using <code>--interpreter</code> option.</li>
<li><code>maturin sdist</code> to generate the source distribution. </li>
</ul>
</li>
<li>Steps to generate bindings using a docker approach.
<ul>
<li><code>docker run --rm -v --release --no-sdist --strip --manylinux off</code></li>
</ul>
</li>
<li>After the bindings are generated by either 2 or 3 the next step is to publish the artifacts.
<ul>
<li>The artifacts can be published via <a href="https://github.com/pypa/twine">twine</a>
<ul>
<li><code>pip install twine</code></li>
<li><code>twine upload -r testpypi target/*</code> this command uploads the artifacts to test.pypi</li>
<li><code>twine upload target/*</code> this command uploads the artifacts to pypi.</li>
</ul>
</li>
<li>The artifacts can be published via <a href="https://github.com/PyO3/maturin">maturin</a>
<ul>
<li><code>maturin publish -b pyo3 -p XXX -u YYY -r https://test.pypi.org/legacy/</code> this publishes the bindings to test.pypi</li>
<li><code>maturin publish -b pyo3 -p XXX -u YYY</code> This publishes the bindings to pypi.</li>
</ul>
</li>
</ul>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
